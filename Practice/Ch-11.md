# Network Protocol Questions - Complete Answers

## 11.6.2 Questions

**Q11-1.** Define framing and give the reason it is needed.

**Answer:** Framing is the process of adding headers, trailers, and control information to data packets to create frames at the data link layer. It's needed because:
- It defines the boundaries of each frame so the receiver knows where one frame ends and another begins
- It provides synchronization between sender and receiver
- It enables error detection and correction
- It allows for addressing and flow control at the data link layer

**Q11-2.** Explain why flags are needed when we use variable-size frames.

**Answer:** Flags are needed for variable-size frames because:
- They mark the beginning and end of each frame (frame delimiters)
- Without fixed frame sizes, the receiver needs explicit indicators to know frame boundaries
- They provide synchronization - the receiver can identify when a new frame starts
- They help in frame recovery after errors - the receiver can resynchronize by looking for flag patterns

**Q11-3.** Assume a new character-oriented protocol is using the 16-bit Unicode as the character set. What should the size of the flag be in this protocol?

**Answer:** The flag size should be 16 bits (2 bytes) to match the Unicode character size. This ensures:
- Consistency with the character encoding scheme
- Proper alignment with character boundaries
- Efficient processing since all elements use the same 16-bit structure

**Q11-4.** Compare and contrast byte-oriented and bit-oriented protocols.

**Answer:** 
**Byte-oriented protocols:**
- Process data in byte (8-bit) units
- Use character-based delimiters and control codes
- Examples: PPP, HDLC in normal response mode
- Easier to implement and debug
- Less efficient for non-text data

**Bit-oriented protocols:**
- Process data at the bit level
- Use bit patterns for control information
- Examples: HDLC, SDLC
- More flexible and efficient
- Can handle any type of data efficiently
- More complex to implement

**Q11-5.** Compare and contrast byte-stuffing and bit-stuffing.

**Answer:**
**Byte-stuffing:**
- Used in byte-oriented protocols
- Inserts escape characters before special bytes
- Works at byte boundaries
- Simpler to implement
- Less efficient (may double frame size in worst case)

**Bit-stuffing:**
- Used in bit-oriented protocols
- Inserts bits to prevent flag patterns in data
- Works at bit level (e.g., insert 0 after five consecutive 1s)
- More efficient
- More complex to implement
- Hardware support often needed

**Q11-6.** In a byte-oriented protocol, should we first unstuff the extra bytes and then remove the flags or reverse the process?

**Answer:** We should first remove the flags and then unstuff the extra bytes. This is because:
- Flags define frame boundaries and must be processed first
- Once flags are removed, we know the actual frame content
- Unstuffing is then applied to the remaining data portion
- This follows the reverse order of the sender's operations

**Q11-7.** In a bit-oriented protocol, should we first unstuff the extra bits and then remove the flags or reverse the process?

**Answer:** We should first remove the flags and then unstuff the extra bits. The reasoning is similar to byte-oriented protocols:
- Flags must be identified and removed first to determine frame boundaries
- Bit unstuffing is then applied to the remaining frame content
- This reverses the sender's process (stuff first, then add flags)

**Q11-8.** Compare and contrast flow control and error control.

**Answer:**
**Flow Control:**
- Manages the rate of data transmission
- Prevents receiver buffer overflow
- Concerned with speed matching between sender and receiver
- Examples: Stop-and-Wait, Sliding Window
- Deals with timing and capacity issues

**Error Control:**
- Detects and corrects transmission errors
- Ensures data integrity
- Uses techniques like checksums, CRC, acknowledgments
- Handles corrupted, lost, or duplicate frames
- Focuses on data accuracy

**Q11-9.** In the Stop-and-Wait Protocol, assume that the sender has only one slot in which to keep the frame to send or the copy of the sent frame. What happens if the network layer delivers a packet to the data-link layer at this moment?

**Answer:** If the network layer delivers a packet while the sender's single slot is occupied:
- The new packet must be blocked/buffered at the network layer
- The data-link layer cannot accept the new packet until the current frame is acknowledged
- This creates backpressure to the network layer
- The protocol must wait for ACK before accepting new data
- This demonstrates the flow control mechanism in action

**Q11-10.** In Example 11.3 (Figure 11.12) how many frames are in transit at the same time?

**Answer:** In the Stop-and-Wait protocol example, only **one frame** is in transit at any given time. This is the fundamental characteristic of Stop-and-Wait - the sender must wait for acknowledgment before sending the next frame.

**Q11-11.** In Example 11.4 (Figure 11.13) how many frames are in transit at the same time?

**Answer:** This would depend on the specific sliding window protocol being used and the window size shown in Figure 11.13. In a sliding window protocol, multiple frames can be in transit simultaneously, up to the window size limit.

**Q11-12.** In the traditional Ethernet protocol (Chapter 13), the frames are sent with the CRC. If the frame is corrupted, the receiving node just discards it. Is this an example of a Simple Protocol or the Stop-and-Wait Protocol? Explain.

**Answer:** This is an example of a **Simple Protocol**, not Stop-and-Wait, because:
- There is no acknowledgment mechanism
- The sender doesn't wait for confirmation before sending the next frame
- No retransmission occurs at the data link layer
- Error detection exists (CRC) but no error recovery
- The protocol assumes higher layers will handle reliability if needed

**Q11-13.** In Figure 11.11, do the ready and blocking states use the same timer? Explain.

**Answer:** No, they use different timers or timer purposes:
- **Ready state:** May use a timer for timeout detection (waiting for ACK)
- **Blocking state:** Uses a timer for retransmission timeout
- The timers serve different functions in the protocol state machine
- They may have different timeout values based on their specific purposes

**Q11-14.** Explain why there is no need for CRC in the Simple Protocol.

**Answer:** CRC might still be useful in Simple Protocol for:
- Basic error detection to avoid processing corrupted frames
- However, it's not essential because:
  - No retransmission mechanism exists anyway
  - Higher layer protocols typically provide error detection
  - The protocol assumes a reliable underlying medium
  - Simplicity is prioritized over error handling

**Q11-15.** In Figure 11.9, we show the packet path as a horizontal line, but the frame path as a diagonal line. Can you explain the reason?

**Answer:** The diagonal line for frames represents:
- **Packet path (horizontal):** Shows logical data flow between network layers
- **Frame path (diagonal):** Shows actual physical transmission over time
- The diagonal indicates transmission delay and propagation time
- It visualizes that frame transmission takes time to travel across the medium
- The slope represents the transmission and propagation characteristics

**Q11-16.** In Figure 11.12, explain why we need a timer at the sending site, but none at the receiving site.

**Answer:** Timer is needed only at sender because:
- **Sender needs timer for:** Detecting lost frames or acknowledgments (timeout and retransmit)
- **Receiver doesn't need timer because:** It only responds to received frames
- The receiver's actions are event-driven (frame arrival)
- Only the sender has the responsibility for reliability and retransmission
- The receiver simply sends ACK when frame arrives correctly

**Q11-17.** Does the duplex communication in Figure 11.10 necessarily mean we need two separate media between the two nodes? Explain.

**Answer:** No, duplex communication doesn't require two separate media:
- **Full-duplex on single medium:** Modern systems can transmit in both directions simultaneously on one medium
- **Examples:** Fiber optic cables, twisted pair with proper signaling
- **Frequency/time division:** Different frequencies or time slots can be used
- **Logical vs. Physical:** The duplex nature is logical - one physical medium can support bidirectional communication

**Q11-18.** Define piggybacking and its benefit.

**Answer:** 
**Piggybacking:** The technique of including acknowledgment information in data frames traveling in the opposite direction, rather than sending separate ACK frames.

**Benefits:**
- Reduces network overhead (fewer separate ACK frames)
- Improves efficiency by combining data and control information
- Reduces bandwidth usage
- Decreases the number of frames transmitted overall

**Q11-19.** In Figure 11.16, which frame type can be used for acknowledgment?

**Answer:** The **I-frame (Information frame)** can be used for acknowledgment through piggybacking. I-frames carry both data and acknowledgment information, allowing acknowledgments to be included with data transmission.

**Q11-20.** Compare Figure 11.6 and Figure 11.21. If both are FSMs, why are there no event/action pairs in the second?

**Answer:** Figure 11.21 likely shows a simplified or high-level state diagram where:
- Events and actions are implied or simplified for clarity
- It may focus on state transitions rather than detailed event/action pairs
- Different notation standards or abstraction levels are used
- The complexity is reduced for pedagogical purposes
- Some FSM representations combine or omit event/action details

**Q11-21.** In PPP, we normally talk about user and system instead of sending and receiving nodes; explain the reason.

**Answer:** PPP uses "user" and "system" terminology because:
- PPP is often used for dial-up connections between user equipment and ISP systems
- It reflects the client-server relationship in point-to-point connections
- "User" represents the end-user device or customer premises equipment
- "System" represents the service provider's equipment or network
- This terminology better describes the typical deployment scenarios for PPP

**Q11-22.** Compare and contrast HDLC with PPP.

**Answer:**
**HDLC (High-level Data Link Control):**
- More general-purpose protocol
- Supports multiple operational modes
- More complex frame structure
- Primarily for dedicated point-to-point or multipoint links
- Includes extensive error and flow control

**PPP (Point-to-Point Protocol):**
- Designed specifically for dial-up and point-to-point connections
- Includes network layer protocol identification
- Authentication support (PAP, CHAP)
- Dynamic IP address assignment
- Simpler than HDLC but adds network layer capabilities
- Better suited for Internet connections

**Q11-23.** Compare the flag byte and the escape byte in PPP. Are they the same? Explain.

**Answer:** No, they are different:
- **Flag byte (0x7E):** Marks frame boundaries (start and end of frame)
- **Escape byte (0x7D):** Used in byte stuffing to escape special characters
- Different functions: delimiter vs. escape mechanism
- Flag byte appears at frame boundaries; escape byte appears within frame data when stuffing is needed
- They work together in the byte stuffing mechanism

**Q11-24.** In Figure 11.20, explain why we need only one address field. Explain why the address is set to the predefined value of (11111111)₂.

**Answer:** 
- **One address field needed:** PPP is point-to-point, so source is always known (the other end)
- **Address value (11111111)₂ = 0xFF:** This is a broadcast address indicating:
  - All stations should accept the frame
  - In point-to-point links, there's only one destination anyway
  - It's a standard placeholder since addressing is not really needed
  - Maintains compatibility with HDLC frame format

## 11.6.3 Problems

**P11-1.** Byte-stuff the following frame payload in which E is the escape byte, F is the flag byte, and D is a data byte other than an escape or a flag character.

Given: D E D D F D D E E D F D

**Answer:** D E E D D E F D D E E E E D E F D
(Insert E before each E and F in the original data)

**P11-2.** Unstuff the following frame payload in which E is the escape byte, F is the flag byte, and D is a data byte other than an escape or a flag character.

Given: E E D E F D D E F E E D D D

**Answer:** E D F D D F E D D D
(Remove the escape byte E before each escaped character)

**P11-3.** Bit-stuff the following frame payload:

Given: 000111111001111101000111111111100001111

**Answer:** 0001111101001111110100011111011111100001111
(Insert 0 after every sequence of five consecutive 1s)

**P11-4.** Unstuff the following frame payload:

Given: 00011111000011111011110001110111110000111

**Answer:** 000111110000111111111000111111110000111
(Remove the 0 that appears after every sequence of five consecutive 1s)

**P11-5.** Assume we change the Stop-and-Wait Protocol to include a NAK (negative feedback), which is used only when a corrupted frame arrives and is discarded. Redraw Figure 11.9 to show this change.

**Answer:** The modified protocol would include:
- Receiver sends NAK when corrupted frame is detected
- Sender retransmits immediately upon receiving NAK (doesn't wait for timeout)
- Timer is still needed for lost frames or lost ACK/NAK
- State diagram would include NAK handling states
- This improves efficiency by providing immediate feedback for corrupted frames

**P11-6.** In Example 11.4 (Figure 11.13), assume the round trip time for a frame is 40 milliseconds. Explain what will happen if we set the time-out in each of the following cases.

a. **35 milliseconds:** Premature timeout - sender will retransmit before ACK arrives, causing unnecessary duplicates

b. **45 milliseconds:** Appropriate timeout - allows sufficient time for round trip, efficient operation

c. **40 milliseconds:** Borderline case - may work but vulnerable to slight delays, could cause occasional unnecessary retransmissions

**P11-7.** Redraw Figure 11.12 using the following scenario:

a. **The first frame is sent and acknowledged:** Normal operation - frame sent, ACK received, next frame can be sent

b. **The second frame is sent and acknowledged, but the acknowledgment is lost:** Sender times out and retransmits, receiver gets duplicate frame, sends ACK again

c. **The second frame is resent, but it is timed-out:** Premature timeout causes retransmission of frame that was still in transit

d. **The second frame is resent and acknowledged:** Eventually successful transmission after retransmissions

**P11-8.** Redraw Figure 11.2 using the following scenario:

a. **Frame 0 is sent, but lost:** Sender times out, retransmits Frame 0

b. **Frame 0 is resent and acknowledged:** Successful transmission after retransmission

c. **Frame 1 is sent and acknowledged, but the acknowledgment is lost:** Sender times out, retransmits Frame 1, receiver detects duplicate

d. **Frame 1 is resent and acknowledged:** Successful acknowledgment received

**P11-9.** In Figure 11.11, show what happens in each of the following cases:

a. **The sender is at the ready state and an error-free ACK arrives:** Transition to ready state, prepare to send next frame

b. **The sender is at the blocking state and a time-out occurs:** Retransmit the frame, remain in blocking state

c. **The sender is at the ready state and a time-out occurs:** This shouldn't normally happen in ready state unless there's a protocol error

**P11-10.** In Figure 11.11, show what happens in each of the following cases:

a. **The receiver is in the ready state and a packet comes from the network layer:** This is incorrect - packets come from physical layer to data link layer, not from network layer to receiver

b. **The receiver is in the ready state and a corrupted frame arrives:** Discard frame, remain in ready state, no ACK sent

c. **The receiver is in the ready state and an acknowledgment arrives:** ACK frames are not processed by receiver in this context (they go to sender)

**P11-11.** Using the following specifications, draw a finite state machine with three states (I, II, and III), five events, and six actions:

a. **If the machine is in state I, two events can occur. If event 1 occurs, the machine moves to state II. If event 2 occurs, the machine performs actions 1 and 2 and moves to state III.**

b. **If the machine is in state II, two events can occur. If event 3 occurs, the machine remains in state II. If event 4 occurs, the machine moves to state III.**

c. **If the machine is in state III, three events can occur. If event 2 occurs, the machine remains in state III. If event 3 occurs, the machine performs actions 1, 2, 4, and 5 moves to state II. If event 5 occurs, the machine performs actions 3, 6 and moves to state I.**

**Answer:** [This would require a state diagram drawing showing three circular states with labeled transitions and actions as specified]

**P11-12.** Using the following specifications, draw a finite state machine with three states (I, II, and III), six events, and four actions:

a. **If the machine is in state I, two events can occur. If event 1 occurs, the machine moves to state III. If event 3 occurs, the machine performs actions 2 and 4 and moves to state II.**

b. **If the machine is in state II, two events can occur. If event 4 occurs, the machine remains in state II. If event 6 occurs, the machine performs actions 1 and 2 and moves to state III.**

c. **If the machine is in state III, three events can occur. If event 2 occurs, the machine remains in state III. If event 6 occurs, the machine performs actions 2, 3, 4, and 5 moves to state I. If event 4 occurs, the machine performs actions 1 and 2 and moves to state I.**

**Answer:** [This would require a state diagram drawing showing the states and transitions as specified]

**P11-13.** Redraw Figure 11.11 using a variable to hold the one-bit sequence number and a variable to hold the one-bit acknowledgment number.

**Answer:** The modified state diagram would include:
- Variables: SeqNum (0 or 1), AckNum (0 or 1)
- States would track these sequence numbers
- Transitions would check and update sequence numbers
- This adds sequence number management to the basic Stop-and-Wait protocol

**P11-14.** Redraw Figure 11.10 using piggybacking.

**Answer:** The piggybacked version would show:
- Data frames carrying acknowledgment information
- Reduced number of separate ACK frames
- I-frames used for both data transmission and acknowledgment
- More efficient bandwidth utilization

**P11-15.** Assume PPP is in the established phase; show payload encapsulated in the frame.

**Answer:** PPP frame with payload would contain:
```
Flag | Address | Control | Protocol | Payload Data | FCS | Flag
7E   | FF      | 03      | (varies) | (user data)  | CRC | 7E
```

**P11-16.** Redraw Figure 11.21 with the system not using authentication.

**Answer:** The state diagram would bypass authentication states:
- Direct transition from Link Establishment to Network Layer Protocol phase
- No Authentication phase states
- Simpler state machine without PAP/CHAP states

**P11-17.** Assume PPP is in the authentication phase, show payload exchanged between the nodes if PPP is using:

a. **PAP:** Password Authentication Protocol frames with username/password in clear text

b. **CHAP:** Challenge Handshake Authentication Protocol frames with challenge/response mechanism using hashed passwords

**P11-18.** Assume the only computer in the residence uses PPP to communicate with the ISP. If the user sends 10 network-layer packets to ISP, how many frames are exchanged in each of the following cases:

a. **Using no authentication:** 10 data frames + potential ACKs (depends on reliability mechanism)

b. **Using PAP for authentication:** Authentication frames (2-4 frames) + 10 data frames + ACKs

c. **Using CHAP for authentication:** Authentication frames (4-6 frames for challenge/response) + 10 data frames + ACKs
