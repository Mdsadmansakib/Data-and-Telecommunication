# Error Detection and Correction Solutions

## P10-11: Parity Check Detection

**Problem**: Show how the following errors can be detected using row and column parity:
- a. An error at (R3, C3)
- b. Two errors at (R3, C4) and (R3, C6) 
- c. Three errors at (R2, C4), (R2, C5), and (R3, C4)
- d. Four errors at (R1, C2), (R1, C6), (R3, C2), and (R3, C6)

**Solution**:

The parity check system uses both row parity (horizontal) and column parity (vertical) bits. An error is detected when either the row parity or column parity (or both) don't match.

**a. Single error at (R3, C3)**: 
- Row 3 parity will be incorrect
- Column 3 parity will be incorrect
- **Detection**: YES - both parities fail

**b. Two errors at (R3, C4) and (R3, C6)**:
- Row 3 parity: two errors cancel out (even number of errors)
- Column 4 parity: fails due to error at (R3, C4)
- Column 6 parity: fails due to error at (R3, C6)
- **Detection**: YES - column parities fail

**c. Three errors at (R2, C4), (R2, C5), and (R3, C4)**:
- Row 2 parity: fails (two errors - even number)
- Row 3 parity: fails (one error - odd number)  
- Column 4 parity: fails (two errors - even number)
- Column 5 parity: fails (one error - odd number)
- **Detection**: YES - multiple parity failures

**d. Four errors at (R1, C2), (R1, C6), (R3, C2), and (R3, C6)**:
- Row 1 parity: passes (two errors cancel out)
- Row 3 parity: passes (two errors cancel out)
- Column 2 parity: passes (two errors cancel out)
- Column 6 parity: passes (two errors cancel out)
- **Detection**: NO - all parities appear correct

---

## P10-12: CRC Generation

**Problem**: Given dataword 101001111 and divisor 10111, show CRC codeword generation using binary division.

**Solution**:

1. **Dataword**: 101001111
2. **Divisor**: 10111 (5 bits, so we need 4 check bits)
3. **Augmented dataword**: 1010011110000 (append 4 zeros)

**Binary Division Process**:
```
                1001011
            _______________
    10111 | 1010011110000
            10111
            -----
             00110
              0000
              ----
              01101
               0000
               ----
               11011
               10111
               -----
               01001
                0000
                ----
                10010
                10111
                -----
                01010
                 0000
                 ----
                 10100
                 10111
                 -----
                 00011
```

**Remainder**: 0011
**CRC Codeword**: 1010011110011

---

## P10-13: Polynomial Operations

**Problem**: Apply operations on corresponding polynomials:

**a. (x³ + x² + x + 1) + (x⁴ + x² + x + 1)**
- Result: x⁴ + x³ + 2x² + 2x + 2
- In GF(2): x⁴ + x³ (coefficients mod 2)

**b. (x³ + x² + x + 1) - (x³ + x² + x + 1)**
- Result: 0

**c. (x³ + x²) × (x⁴ + x² + x + 1)**
- Result: x⁷ + x⁶ + x⁵ + x⁴ + x⁶ + x⁴ + x³ + x²
- Simplified: x⁷ + 2x⁶ + x⁵ + 2x⁴ + x³ + x²
- In GF(2): x⁷ + x⁵ + x³ + x²

**d. (x³ + x² + x + 1) ÷ (x² + 1)**
- Quotient: x + 1
- Remainder: 2x
- In GF(2): Quotient = x + 1, Remainder = 0

---

## P10-14: Polynomial Representations

**a. Polynomial representation of 101110**:
- x⁵ + x³ + x² + x¹

**b. Shifting 101110 three bits to the left**:
- Result: 101110000
- Polynomial: x⁸ + x⁶ + x⁵ + x⁴

**c. Using polynomials**: Multiply by x³
- (x⁵ + x³ + x² + x¹) × x³ = x⁸ + x⁶ + x⁵ + x⁴

**d. Shifting 101110 four bits to the right**:
- Result: 0000101110 → 10.1110 → 10 (integer part)
- This is division by x⁴

**e. Using polynomials**: Divide by x⁴
- (x⁵ + x³ + x² + x¹) ÷ x⁴ = x¹ + remainder

---

## P10-15: CRC Generators for Single Bit Error

**Problem**: Which CRC generators guarantee detection of single bit error?

**Analysis**:
- **a. x⁴ + x + 1**: Degree 4, can detect single errors ✓
- **b. x⁴ + x²**: Factors as x²(x² + 1), cannot guarantee single error detection ✗
- **c. 1**: Degree 0, cannot detect any errors ✗  
- **d. x² + 1**: Degree 2, can detect single errors ✓

**Answer**: a and d

---

## P10-16: CRC-8 Polynomial Analysis

**Problem**: Referring to CRC-8 polynomial in Table 10.7, answer:
- a. Does it detect a single error?
- b. Does it detect a burst error of size 6?
- c. Probability of detecting burst error of size 9?
- d. Probability of detecting burst error of size 15?

**Solution**:

**a. Single error detection**: YES
- Any CRC with degree r ≥ 1 can detect single bit errors
- CRC-8 has degree 8, so it detects single errors

**b. Burst error of size 6**: YES  
- CRC of degree r can detect all burst errors of length ≤ r
- CRC-8 can detect all burst errors up to 8 bits

**c. Burst error of size 9**:
- For burst errors of length r+1, detection probability = 1 - 2^(-r)
- For CRC-8: P = 1 - 2^(-8) = 1 - 1/256 = **255/256 ≈ 99.61%**

**d. Burst error of size 15**:
- For burst errors of length > r+1, detection probability = 1 - 2^(-r)  
- For CRC-8: P = 1 - 2^(-8) = **255/256 ≈ 99.61%**

---

## P10-17: CRC-32 Polynomial Analysis

**Problem**: Referring to CRC-32 polynomial in Table 10.4, answer:
- a. Does it detect a single error?
- b. Does it detect a burst error of size 16?
- c. Probability of detecting burst error of size 33?
- d. Probability of detecting burst error of size 55?

**Solution**:

**a. Single error detection**: YES
- CRC-32 has degree 32, detects all single bit errors

**b. Burst error of size 16**: YES
- CRC-32 can detect all burst errors up to 32 bits

**c. Burst error of size 33**:
- Length = 32 + 1, so P = 1 - 2^(-32) = **1 - 1/4,294,967,296 ≈ 99.999999977%**

**d. Burst error of size 55**:
- Length > 32 + 1, so P = 1 - 2^(-32) = **1 - 1/4,294,967,296 ≈ 99.999999977%**

---

## P10-18: Checksum Simulation

**Problem**: Simulate checksum algorithm for 16-bit words: (ATA2)₁₆, (CABF)₁₆, (903A)₁₆, and (A123)₁₆.

**Solution**:

**Step-by-step calculation**:
1. ATA2₁₆ = 43426₁₀
2. CABF₁₆ = 51903₁₀  
3. 903A₁₆ = 36922₁₀
4. A123₁₆ = 41251₁₀

**Sum**: 43426 + 51903 + 36922 + 41251 = 173502₁₀

**Wrap-around addition**:
- 173502₁₀ = 2A5FE₁₆
- Carry: 2₁₆, Sum: A5FE₁₆
- A5FE + 2 = A600₁₆

**Checksum**: One's complement of A600₁₆ = 59FF₁₆

---

## P10-19: Traditional Checksum Calculation

**Problem**: Find checksum of 43,689, 64,463, 45,112, and 59,683 using one's complement arithmetic.

**Solution**:

**In binary (16-bit)**:
- 43,689 = AA99₁₆
- 64,463 = FBCF₁₆  
- 45,112 = B028₁₆
- 59,683 = E923₁₆

**Sum calculation**:
AA99 + FBCF + B028 + E923 = 2E013₁₆

**Wrap-around**:
- Carry: 2₁₆
- E013 + 2 = E015₁₆

**Checksum**: ~E015₁₆ = 1FEA₁₆

---

## P10-20: Special Checksum Case

**Problem**: Sender has two data items: (4567)₁₆ and (BA98)₁₆. Find checksum value.

**Solution**:

**Addition**:
4567₁₆ + BA98₁₆ = FFFF₁₆

**Checksum**: ~FFFF₁₆ = 0000₁₆

**Special case**: When sum equals FFFF₁₆, checksum is 0000₁₆

---

## P10-21: Fletcher Algorithm Simulation

**Problem**: Simulate Fletcher algorithm for bytes: (2B)₁₆, (3F)₁₆, (6A)₁₆, and (AF)₁₆. Show it's a weighted checksum.

**Solution**:

**Fletcher Algorithm**:
- S1 = sum of all bytes mod 255
- S2 = sum of partial sums mod 255

**Calculations**:
```
Byte 1: 2B₁₆ = 43₁₀
S1 = 43, S2 = 43

Byte 2: 3F₁₆ = 63₁₀  
S1 = (43 + 63) mod 255 = 106
S2 = (43 + 106) mod 255 = 149

Byte 3: 6A₁₆ = 106₁₀
S1 = (106 + 106) mod 255 = 212  
S2 = (149 + 212) mod 255 = 106

Byte 4: AF₁₆ = 175₁₀
S1 = (212 + 175) mod 255 = 132
S2 = (106 + 132) mod 255 = 238
```

**Fletcher Checksum**: S2 || S1 = EE84₁₆

**Weighted nature**: Each byte is multiplied by its position weight in S2 calculation.

---

## P10-22: Adler Algorithm Simulation

**Problem**: Simulate Adler algorithm for words: (FBFF)₁₆ and (EFAA)₁₆. Show it's weighted.

**Solution**:

**Adler-32 Algorithm**:
- A = 1 + sum of bytes mod 65521
- B = sum of A values mod 65521

**For FBFF₁₆** (bytes: FB, FF):
```
Initial: A = 1, B = 0
Byte FB₁₆ = 251₁₀: A = (1 + 251) = 252, B = (0 + 252) = 252  
Byte FF₁₆ = 255₁₀: A = (252 + 255) = 507, B = (252 + 507) = 759
```

**For EFAA₁₆** (bytes: EF, AA):
```
Byte EF₁₆ = 239₁₀: A = (507 + 239) = 746, B = (759 + 746) = 1505
Byte AA₁₆ = 170₁₀: A = (746 + 170) = 916, B = (1505 + 916) = 2421
```

**Adler Checksum**: (B << 16) | A = (2421 << 16) | 916 = 09750394₁₆

---

## P10-23: ISBN-10 Checksum

**Problem**: Calculate check digit for ISBN-10: 0-07-296775-C.

**Solution**:

**ISBN-10 formula**: Σ(i × dᵢ) mod 11 = 0, where i = 10,9,8,...,1

**Calculation**:
```
(10×0) + (9×0) + (8×7) + (7×2) + (6×9) + (5×6) + (4×7) + (3×7) + (2×5) + (1×C) = 0 (mod 11)

0 + 0 + 56 + 14 + 54 + 30 + 28 + 21 + 10 + C = 0 (mod 11)
213 + C = 0 (mod 11)
213 = 4 (mod 11)
C = 11 - 4 = 7
```

**Check digit**: C = 7

---

## P10-24: ISBN-13 Checksum

**Problem**: Calculate check digit for ISBN-13: 978-0-07-296775-C.

**Solution**:

**ISBN-13 formula**: Σ(wᵢ × dᵢ) mod 10 = 0, weights alternate 1,3,1,3...

**Calculation**:
```
(1×9) + (3×7) + (1×8) + (3×0) + (1×0) + (3×7) + (1×2) + (3×9) + (1×6) + (3×7) + (1×7) + (3×5) + (1×C) = 0 (mod 10)

9 + 21 + 8 + 0 + 0 + 21 + 2 + 27 + 6 + 21 + 7 + 15 + C = 0 (mod 10)
137 + C = 0 (mod 10)
137 = 7 (mod 10)
C = 10 - 7 = 3
```

**Check digit**: C = 3

---

## P10-25: Interleaving FEC

**Problem**: In interleaving FEC, first packet has odd samples (1-20), second has even samples (1-20), third reorders samples. If third packet is lost, what's missed at receiver?

**Solution**:

**Packet contents**:
- Packet 1: Samples 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 (from first 20)
- Packet 2: Samples 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 (from first 20)  
- Packet 3: Contains reordered/processed samples

**If Packet 3 is lost**:
- Receiver has all original samples 1-20
- Missing: The reordered/processed version of these samples
- **Impact**: Depends on application - if Packet 3 contains essential reconstruction data, quality degrades but basic samples remain

---

## P10-26: Hamming Distance FEC

**Problem**: Send dataword of 2 bits using FEC based on Hamming distance. Show auto-correction for one-bit error.

**Datawords/Codewords**:
- 00 → 00000
- 01 → 01011  
- 10 → 10101
- 11 → 11110

**Auto-correction example**:
If received: 00100 (error in position 3)
- Distance from 00000: 1 ✓ (closest)
- Distance from 01011: 3
- Distance from 10101: 3  
- Distance from 11110: 4

**Corrected to**: 00000 (original dataword: 00)

---

## P10-27: Redundant Bits for Single Error Correction

**Problem**: Find relationship between k (dataword bits) and r (redundant bits) for single error correction.

**Solution**:

For single error correction using Hamming codes:
- Total codeword bits: n = k + r
- Number of possible error patterns: n + 1 (including no error)
- Number of possible syndromes: 2ʳ

**Relationship**: 2ʳ ≥ k + r + 1

**Calculations**:
- k = 1: 2ʳ ≥ 4, so r = 2
- k = 2: 2ʳ ≥ 5, so r = 3  
- k = 5: 2ʳ ≥ 8, so r = 3
- k = 50: 2ʳ ≥ 56, so r = 6
- k = 1000: 2ʳ ≥ 1010, so r = 10

---

## P10-28: Redundant Bits for Two Error Correction

**Problem**: Find r for correcting up to 2 errors in dataword of size k.

**Solution**:

For correcting up to 2 errors:
- Possible error patterns: C(n,0) + C(n,1) + C(n,2)
- Where C(n,x) = n!/(x!(n-x)!)

**Relationship**: 2ʳ ≥ 1 + n + n(n-1)/2 = 1 + n + n²/2 - n/2 = 1 + n/2 + n²/2

Since n = k + r:
2ʳ ≥ 1 + (k+r)/2 + (k+r)²/2

**Calculations** (approximate):
- k = 1: r = 4
- k = 2: r = 5
- k = 5: r = 7
- k = 50: r = 12
- k = 1000: r = 21

---

## P10-29: General Formula for m Error Correction

**Problem**: Develop formula for correcting m errors in codeword of size n.

**Solution**:

**General Relationship**:
2ʳ ≥ Σᵢ₌₀ᵐ C(n,i)

Where C(n,i) = n!/(i!(n-i)!) represents choosing i positions for errors out of n total positions.

This is known as the **Sphere Packing Bound** or **Hamming Bound**.

**Explanation**:
- Each correctable error pattern requires a unique syndrome
- We have 2ʳ possible syndromes
- We need to correct all error patterns with 0, 1, 2, ..., m errors
- The sum represents all possible error patterns we must distinguish

---

## P10-30: FEC Overhead Calculation

**Problem**: 100 packets, high-resolution (700 bits avg), low-resolution (400 bits avg). Calculate FEC overhead.

**Solution**:

**Assumptions**:
- High-resolution packets are original data
- Low-resolution packets are redundant FEC data
- Equal number of high and low resolution packets (50 each)

**Calculations**:
- High-resolution total: 50 × 700 = 35,000 bits
- Low-resolution total: 50 × 400 = 20,000 bits
- Total transmission: 55,000 bits
- Original data: 35,000 bits
- Extra FEC bits: 20,000 bits

**Percentage overhead**: (20,000 ÷ 35,000) × 100% = **57.14%**

**Alternative interpretation** (if we consider total vs original):
- Overhead = (20,000 ÷ 55,000) × 100% = **36.36%**
